Project: EchoTune AI â€” Enhanced Cursor Rules
Repository Type: Full-Stack Music AI Platform with MCP Integration
Tech Stack: React 19 + Vite + Node.js 20 + Express + MongoDB + Redis + Python ML

## ðŸŽ¯ Core Development Standards

### JavaScript/JSX Standards
- Use modern ES2024+ features with consistent destructuring and arrow functions
- Prefer `const` over `let`, use template literals for string interpolation
- Implement proper error boundaries in React components
- Use React 19's concurrent features: Suspense, Error Boundaries, and Server Components
- Maintain component composition over inheritance patterns
- Generate comprehensive JSDoc documentation for all functions and components

### Node.js Backend Standards
- Use ES modules (`import/export`) consistently across backend
- Implement comprehensive error handling with custom error classes
- Use middleware pattern for cross-cutting concerns (auth, logging, validation)
- Follow RESTful API design principles with proper HTTP status codes
- Implement request validation using Joi or similar schema validation
- Use async/await exclusively, avoid callback patterns

### Database & Caching Patterns
- MongoDB: Use aggregation pipelines for complex queries, implement proper indexing
- Redis: Implement cache-aside pattern with TTL-based expiration
- Use transactions for multi-document operations
- Implement connection pooling and proper error handling
- Generate data access layer with repository pattern

### Testing Requirements
- Unit tests: >80% coverage for business logic and utilities
- Integration tests: All API endpoints with success/error scenarios
- React Testing Library for component tests with user interaction patterns
- Mock external dependencies (Spotify API, OpenAI, etc.) in tests
- Performance tests for critical user flows

## ðŸ¤– Advanced AI Model Selection & Orchestration

### Primary Model Routing
```
Task Classification â†’ Model Selection:

ARCHITECTURE & PLANNING:
- Use: Advanced AI Integration (Perplexity-based Llama 3.1 Sonar)
- When: System design, database schema, API architecture, scalability planning
- Context: Include current architecture diagrams, performance requirements

CODE GENERATION & REFACTORING:
- Use: Claude 3.5 Sonnet (preferred) or GPT-4
- When: Complex business logic, React components, API endpoints
- Context: Include existing patterns, style guides, test requirements

QUICK FIXES & SIMPLE TASKS:
- Use: GPT-4-mini or Llama 3.1 8B
- When: Bug fixes, simple utilities, documentation updates
- Context: Minimal context, focus on immediate task

RESEARCH & BEST PRACTICES:
- Use: Perplexity Sonar Pro
- When: Technology decisions, security research, performance optimization
- Trigger Words: "latest", "best practice", "security", "performance", "2024", "2025"
- Always include: current tech stack context, specific requirements
```

### Multi-Model Orchestration
- **Parallel Processing**: Use Claude + Perplexity for code generation with research validation
- **Consensus Checking**: Critical architectural decisions require 2+ model agreement
- **Automatic Fallbacks**: GPT-4 â†’ Claude â†’ GPT-4-mini for availability issues
- **Cost Optimization**: Cache Perplexity research results for 24h, use cheaper models for iterations

### Research Integration Triggers
```
Automatic Perplexity Research:
- When implementing new npm packages or Python libraries
- Before suggesting security-related code changes
- When performance issues are detected (>1s response times)
- For API integration patterns not in existing codebase
- When user mentions "industry standard" or "best practice"
```

## ðŸš€ Enhanced Context Management

### Smart File Inclusion
```
@Recommended High Priority:
- package.json, vite.config.js, server.js, server-phase3.js
- .cursor/mcp.json, .cursor/workflows/*.json
- src/server.js, src/api/ai-integration/*.js
- Key React components: src/frontend/App.jsx
- Database models: src/database/*.js
- Test configurations: tests/jest.config.js

Dynamic Context (based on current task):
- API Work: Include src/api/*, middleware patterns, error handling
- Frontend Work: Include src/frontend/*, component patterns, styling
- ML Work: Include scripts/*, ml_datasets/, Python requirements
- MCP Work: Include mcp-servers/*, integration patterns
```

### Progressive Context Building
- Start with core files (<50 files total)
- Add related dependencies based on import/require statements
- Include test files only when testing context is active
- Exclude build artifacts, logs, and generated documentation
- Monitor context window usage and trim less relevant files

### Performance Optimization Rules
- Prefer targeted file reads over full directory scans
- Use `@Web` research only for unknowns not covered by existing codebase
- Cache frequently accessed patterns and configurations
- Limit concurrent API calls to prevent rate limiting

## ðŸ”„ Automated Workflow Integration

### Pre-Development Research
```
Before starting any feature:
1. Research current best practices for the technology stack
2. Check for security vulnerabilities in planned approach
3. Validate against existing architecture patterns
4. Identify reusable components or utilities
```

### Code Quality Gates
```
After any substantial changes:
1. Run ESLint and Prettier validation
2. Execute relevant test suites
3. Check for security anti-patterns
4. Validate performance impact
5. Update documentation if needed
```

### Continuous Learning Triggers
- Research new patterns when generating novel solutions
- Update knowledge base with successful implementation patterns
- Track and suggest refactoring opportunities
- Monitor for deprecated dependencies or patterns

## ðŸŽµ Domain-Specific Rules (Music AI Platform)

### Music Data Handling
- Use proper audio format validation (MP3, FLAC, WAV)
- Implement streaming-friendly data structures for large audio files
- Respect music copyright considerations in all data processing
- Use appropriate audio processing libraries (Web Audio API, FFmpeg)

### Spotify Integration Patterns
- Implement proper OAuth 2.0 flows with refresh token handling
- Use rate limiting strategies to respect Spotify API limits
- Cache playlist and track data appropriately
- Handle playlist privacy settings correctly

### AI/ML Integration Standards
- Validate all input data before sending to AI models
- Implement proper error handling for AI API failures
- Use streaming responses for long-running AI operations
- Cache AI model results to reduce costs and latency

## ðŸ”’ Enhanced Security & Compliance

### API Security
- Validate all inputs using schema validation
- Implement rate limiting on all public endpoints
- Use proper CORS configuration for frontend/backend communication
- Encrypt sensitive data in transit and at rest
- Never log API keys or sensitive user data

### Music Industry Compliance
- Implement proper attribution for music recommendations
- Respect user privacy in music preference analysis
- Use proper licensing for any music content processing
- Follow DMCA guidelines for user-generated content

## ðŸ›  MCP Server Standards

### MCP Integration Patterns
- Use proper error handling and timeout configurations
- Implement resource management for MCP tools
- Follow MCP protocol specifications exactly
- Document all custom MCP server capabilities
- Test MCP servers in isolation before integration

### Research Workflow Standards
- Always cite sources from Perplexity research
- Validate research accuracy against official documentation
- Cache research results to prevent duplicate API calls
- Format research results for easy consumption by development tools

## ðŸ“Š Performance & Monitoring

### Response Time Targets
- API Endpoints: p95 < 500ms for simple queries, < 2s for complex
- Frontend Rendering: First Contentful Paint < 1.5s
- Database Queries: Simple queries < 100ms, complex < 1s
- AI Model Responses: < 3s for code generation, < 10s for research

### Resource Management
- Memory usage monitoring for all services
- Database connection pooling with proper limits
- Redis memory management with appropriate eviction policies
- File system monitoring for log rotation and cleanup

## ðŸš¨ Error Handling Playbook

### Development Errors
- **Test Failures**: Research error patterns, propose fixes with explanation
- **Linter Errors**: Auto-fix safe patterns, manual review for complex issues
- **Build Failures**: Check dependency conflicts, suggest resolution strategies
- **Performance Issues**: Profile code, research optimization patterns

### Production Error Response
- **API Errors**: Implement proper error codes and user-friendly messages
- **Database Errors**: Graceful degradation with proper fallback strategies
- **AI Service Failures**: Implement circuit breaker patterns with fallbacks
- **Integration Failures**: Retry logic with exponential backoff

## ðŸ“ Documentation Standards

### Code Documentation
- JSDoc for all functions with parameter types and examples
- README files for all major components and services
- API documentation using OpenAPI/Swagger specifications
- Architecture decision records (ADRs) for major design choices

### Knowledge Management
- Maintain updated technology decision rationale
- Document all external integrations and their configurations
- Keep runbooks for common operational procedures
- Regular updates to onboarding documentation

## ðŸŽ¯ YOLO Mode (Enhanced Automation)

### Expanded Allowlist (when explicitly enabled)
- **Code Quality**: `npm run lint:fix`, `npm run format`
- **Testing**: `npm run test:unit`, `npm run test:integration`
- **Documentation**: Auto-generation of API docs and code comments
- **Dependencies**: Automated security patch application (non-breaking)

### Enhanced Safety Measures
- **Backup Creation**: Auto-create git stash before major changes
- **Rollback Capability**: Provide clear rollback instructions
- **Change Validation**: Run tests after any automated changes
- **Human Approval**: Request confirmation for any structural changes

---

## ðŸŽµ Music AI Context Awareness

When working on music-related features, automatically:
- Research current music technology trends and best practices
- Consider accessibility for users with hearing impairments
- Validate against music theory principles when applicable
- Ensure compatibility with major streaming platforms
- Respect cultural sensitivity in music recommendations