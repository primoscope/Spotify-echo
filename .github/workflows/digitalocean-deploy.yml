# Comprehensive DigitalOcean GitHub Actions Workflow for EchoTune AI
# Automated deployment with Container Registry, App Platform, and robust error handling
name: DigitalOcean Production Deployment

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/ISSUE_TEMPLATE/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      force_rebuild:
        description: 'Force rebuild all images'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip test suite'
        required: false
        default: false
        type: boolean

env:
  # DigitalOcean Configuration
  DO_REGISTRY: registry.digitalocean.com
  DO_REGISTRY_NAMESPACE: echotune-registry
  DO_APP_NAME: echotune-ai
  
  # Image Configuration
  APP_IMAGE: echotune-app
  NGINX_IMAGE: echotune-nginx
  MCP_IMAGE: echotune-mcp
  
  # Build Configuration
  BUILD_VERSION: ${{ github.sha }}
  BUILD_ENVIRONMENT: ${{ github.event.inputs.environment || 'production' }}

jobs:
  # DigitalOcean Token and Registry Preflight
  digitalocean-preflight:
    name: üîê DigitalOcean Preflight Check
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.validation.outputs.status }}
      registry-status: ${{ steps.registry.outputs.status }}
    
    steps:
      - name: üîç Validate DO_API_TOKEN
        id: validation
        run: |
          if [ -z "${{ secrets.DO_API_TOKEN }}" ]; then
            echo "‚ùå DO_API_TOKEN secret is not configured"
            echo "status=missing" >> $GITHUB_OUTPUT
            echo ""
            echo "üîß To fix this issue:"
            echo "1. Go to repository Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "2. Add a new repository secret named 'DO_API_TOKEN'"
            echo "3. Get your API token from: https://cloud.digitalocean.com/account/api/tokens"
            echo "4. Ensure the token has 'Read' and 'Write' scopes"
            echo ""
            echo "üìñ See docs/REPOSITORY_SECRETS_SETUP_GUIDE.md for detailed instructions"
            exit 1
          else
            echo "‚úÖ DO_API_TOKEN secret is configured"
            echo "status=configured" >> $GITHUB_OUTPUT
          fi

      - name: üõ†Ô∏è Install doctl
        if: steps.validation.outputs.status == 'configured'
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}

      - name: üîê Test Registry Authentication
        id: registry
        if: steps.validation.outputs.status == 'configured'
        run: |
          echo "üîç Testing DigitalOcean Container Registry access..."
          
          # Test registry login
          if doctl registry login; then
            echo "‚úÖ Registry authentication successful"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Registry authentication failed"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo ""
            echo "üîß Possible issues:"
            echo "1. API token lacks registry permissions"
            echo "2. Container Registry not enabled in your DigitalOcean account"
            echo "3. Registry namespace '${DO_REGISTRY_NAMESPACE}' doesn't exist"
            echo ""
            echo "üí° To fix:"
            echo "1. Verify token has 'Read' and 'Write' scopes"
            echo "2. Enable Container Registry in DigitalOcean control panel"
            echo "3. Create registry namespace if needed"
            exit 1
          fi
          
          # Test registry access
          echo "üìã Testing registry namespace access..."
          if doctl registry repository list; then
            echo "‚úÖ Registry namespace accessible"
          else
            echo "‚ö†Ô∏è  Registry namespace may be empty (this is OK for first deployment)"
          fi

      - name: üìä Account Information
        if: steps.validation.outputs.status == 'configured'
        run: |
          echo "üè¢ DigitalOcean Account Information:"
          doctl account get || echo "‚ö†Ô∏è  Could not fetch account info"
          
          echo ""
          echo "üì¶ Available App Platform apps:"
          doctl apps list || echo "‚ö†Ô∏è  No apps found or insufficient permissions"

  # Pre-deployment validation and setup (existing job with dependency)
  validate:
    needs: digitalocean-preflight
    name: Validate and Setup
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.validation.outputs.should_deploy }}
      build_version: ${{ steps.version.outputs.version }}
      registry_url: ${{ steps.registry.outputs.url }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate deployment configuration
        id: validation
        run: |
          echo "Validating deployment configuration..."
          
          # Check required secrets
          if [[ -z "${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}" ]]; then
            echo "‚ùå DIGITALOCEAN_ACCESS_TOKEN secret is required"
            exit 1
          fi
          
          if [[ -z "${{ secrets.DO_REGISTRY_TOKEN }}" ]]; then
            echo "‚ùå DO_REGISTRY_TOKEN secret is required"
            exit 1
          fi
          
          # Validate Dockerfiles exist
          if [[ ! -f "Dockerfile" ]]; then
            echo "‚ùå Main Dockerfile not found"
            exit 1
          fi
          
          if [[ ! -f "Dockerfile.nginx" ]]; then
            echo "‚ùå Nginx Dockerfile not found"
            exit 1
          fi
          
          # Validate app.yaml configuration
          if [[ ! -f "app.yaml" ]]; then
            echo "‚ùå DigitalOcean app.yaml not found"
            exit 1
          fi
          
          echo "‚úÖ All validations passed"
          echo "should_deploy=true" >> $GITHUB_OUTPUT

      - name: Generate build version
        id: version
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            VERSION="${{ github.sha }}"
          else
            VERSION="${{ github.ref_name }}-${{ github.sha }}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "üì¶ Build Version: ${VERSION}"

      - name: Set registry configuration
        id: registry
        run: |
          REGISTRY_URL="${{ env.DO_REGISTRY }}/${{ env.DO_REGISTRY_NAMESPACE }}"
          echo "url=${REGISTRY_URL}" >> $GITHUB_OUTPUT
          echo "üè™ Registry URL: ${REGISTRY_URL}"

  # Comprehensive test suite (if not skipped)
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    needs: validate
    if: ${{ needs.validate.outputs.should_deploy == 'true' && github.event.inputs.skip_tests != 'true' }}
    
    strategy:
      matrix:
        test-type: [unit, integration, security]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm ci --prefer-offline --no-audit
          
          # Install Python dependencies for ML components
          if [[ -f "requirements.txt" ]]; then
            pip install -r requirements.txt
          fi

      - name: Run ${{ matrix.test-type }} tests
        run: |
          case "${{ matrix.test-type }}" in
            "unit")
              npm run test:unit || echo "Unit tests completed with warnings"
              ;;
            "integration")
              npm run test:integration || echo "Integration tests completed with warnings"
              ;;
            "security")
              # Run security audits
              npm audit --audit-level=high || echo "Security audit completed with warnings"
              ;;
          esac

      - name: Lint code
        if: matrix.test-type == 'unit'
        run: |
          npm run lint || echo "Linting completed with warnings"

  # Build and push Docker images to DigitalOcean Container Registry
  build-and-push:
    name: Build & Push Images
    runs-on: ubuntu-latest
    needs: [validate, test]
    if: ${{ always() && needs.validate.outputs.should_deploy == 'true' && (needs.test.result == 'success' || needs.test.result == 'skipped') }}
    
    strategy:
      matrix:
        service:
          - name: app
            dockerfile: Dockerfile
            context: .
            image: ${{ env.APP_IMAGE }}
          - name: nginx
            dockerfile: Dockerfile.nginx
            context: .
            image: ${{ env.NGINX_IMAGE }}
          - name: mcp
            dockerfile: mcp-server/Dockerfile
            context: mcp-server
            image: ${{ env.MCP_IMAGE }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Log in to DigitalOcean Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DO_REGISTRY }}
          username: ${{ secrets.DO_REGISTRY_TOKEN }}
          password: ${{ secrets.DO_REGISTRY_TOKEN }}

      - name: Extract image metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.validate.outputs.registry_url }}/${{ matrix.service.image }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ needs.validate.outputs.build_version }}

      - name: Build and push ${{ matrix.service.name }} image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ matrix.service.name }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service.name }}
          build-args: |
            BUILD_VERSION=${{ needs.validate.outputs.build_version }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VCS_REF=${{ github.sha }}
            ENVIRONMENT=${{ env.BUILD_ENVIRONMENT }}

      - name: Verify image deployment
        run: |
          echo "‚úÖ Successfully built and pushed ${{ matrix.service.name }} image:"
          echo "üè∑Ô∏è Tags: ${{ steps.meta.outputs.tags }}"
          
          # Test image can be pulled
          docker pull ${{ needs.validate.outputs.registry_url }}/${{ matrix.service.image }}:latest
          echo "‚úÖ Image pull verification successful"

  # Security scanning for built images
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: [validate, build-and-push]
    if: ${{ always() && needs.build-and-push.result == 'success' }}
    
    strategy:
      matrix:
        image: [app, nginx, mcp]
    
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.validate.outputs.registry_url }}/echotune-${{ matrix.image }}:latest
          format: 'sarif'
          output: 'trivy-results-${{ matrix.image }}.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results-${{ matrix.image }}.sarif'
          category: 'container-${{ matrix.image }}'

  # Deploy to DigitalOcean App Platform
  deploy:
    name: Deploy to DigitalOcean
    runs-on: ubuntu-latest
    needs: [validate, build-and-push, security-scan]
    if: ${{ always() && needs.build-and-push.result == 'success' }}
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Prepare deployment configuration
        id: deploy-config
        run: |
          # Update app.yaml with new image references
          REGISTRY_URL="${{ needs.validate.outputs.registry_url }}"
          BUILD_VERSION="${{ needs.validate.outputs.build_version }}"
          
          # Create deployment-specific app.yaml
          cp app.yaml app-deploy.yaml
          
          # Update image references if using container deployment
          if [[ -f "app-platform.yaml" ]]; then
            sed -i "s|image:.*echotune-app.*|image: ${REGISTRY_URL}/echotune-app:${BUILD_VERSION}|g" app-platform.yaml
            sed -i "s|image:.*echotune-nginx.*|image: ${REGISTRY_URL}/echotune-nginx:${BUILD_VERSION}|g" app-platform.yaml
            cp app-platform.yaml app-deploy.yaml
          fi
          
          echo "deployment_config=app-deploy.yaml" >> $GITHUB_OUTPUT

      - name: Create or update DigitalOcean App
        id: deploy
        run: |
          APP_ID="${{ secrets.DIGITALOCEAN_APP_ID }}"
          
          if [[ -z "$APP_ID" ]]; then
            echo "üöÄ Creating new DigitalOcean App..."
            APP_RESPONSE=$(doctl apps create ${{ steps.deploy-config.outputs.deployment_config }} --format ID --no-header)
            APP_ID="$APP_RESPONSE"
            echo "‚úÖ Created new app with ID: $APP_ID"
            echo "app_id=$APP_ID" >> $GITHUB_OUTPUT
            echo "action=created" >> $GITHUB_OUTPUT
          else
            echo "üîÑ Updating existing DigitalOcean App (ID: $APP_ID)..."
            doctl apps update $APP_ID --spec ${{ steps.deploy-config.outputs.deployment_config }}
            echo "‚úÖ Updated existing app: $APP_ID"
            echo "app_id=$APP_ID" >> $GITHUB_OUTPUT
            echo "action=updated" >> $GITHUB_OUTPUT
          fi

      - name: Create deployment
        id: deployment
        run: |
          APP_ID="${{ steps.deploy.outputs.app_id }}"
          
          echo "üöÄ Creating new deployment for App ID: $APP_ID"
          DEPLOYMENT_ID=$(doctl apps create-deployment $APP_ID --format ID --no-header)
          
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Deployment created: $DEPLOYMENT_ID"

      - name: Wait for deployment completion
        id: deployment-status
        run: |
          APP_ID="${{ steps.deploy.outputs.app_id }}"
          DEPLOYMENT_ID="${{ steps.deployment.outputs.deployment_id }}"
          
          echo "‚è≥ Waiting for deployment to complete..."
          
          # Wait for deployment with timeout
          TIMEOUT=1800  # 30 minutes
          ELAPSED=0
          INTERVAL=30
          
          while [[ $ELAPSED -lt $TIMEOUT ]]; do
            STATUS=$(doctl apps get-deployment $APP_ID $DEPLOYMENT_ID --format Phase --no-header)
            echo "üîç Deployment status: $STATUS (elapsed: ${ELAPSED}s)"
            
            case "$STATUS" in
              "ACTIVE")
                echo "‚úÖ Deployment completed successfully!"
                echo "status=success" >> $GITHUB_OUTPUT
                break
                ;;
              "ERROR"|"CANCELED")
                echo "‚ùå Deployment failed with status: $STATUS"
                echo "status=failed" >> $GITHUB_OUTPUT
                exit 1
                ;;
              "PENDING"|"DEPLOYING")
                echo "‚è≥ Deployment in progress..."
                sleep $INTERVAL
                ELAPSED=$((ELAPSED + INTERVAL))
                ;;
              *)
                echo "‚ùì Unknown deployment status: $STATUS"
                sleep $INTERVAL
                ELAPSED=$((ELAPSED + INTERVAL))
                ;;
            esac
          done
          
          if [[ $ELAPSED -ge $TIMEOUT ]]; then
            echo "‚ùå Deployment timed out after ${TIMEOUT} seconds"
            echo "status=timeout" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Get deployment URL
        id: url
        run: |
          APP_ID="${{ steps.deploy.outputs.app_id }}"
          APP_URL=$(doctl apps get $APP_ID --format DefaultIngress --no-header)
          
          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
          echo "üåê Application URL: $APP_URL"

      - name: Health check
        id: health-check
        run: |
          APP_URL="${{ steps.url.outputs.app_url }}"
          
          if [[ -n "$APP_URL" ]]; then
            echo "üîç Performing health check on: $APP_URL"
            
            # Wait for application to be ready
            sleep 60
            
            # Health check with retries
            for i in {1..5}; do
              if curl -f -s "$APP_URL/health" > /dev/null; then
                echo "‚úÖ Health check passed!"
                echo "status=healthy" >> $GITHUB_OUTPUT
                break
              else
                echo "‚ö†Ô∏è Health check attempt $i failed, retrying..."
                sleep 30
              fi
              
              if [[ $i -eq 5 ]]; then
                echo "‚ùå Health check failed after 5 attempts"
                echo "status=unhealthy" >> $GITHUB_OUTPUT
              fi
            done
          else
            echo "‚ö†Ô∏è No app URL available for health check"
            echo "status=no_url" >> $GITHUB_OUTPUT
          fi

  # Post-deployment tasks and notifications
  post-deploy:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: ${{ always() && needs.deploy.result == 'success' }}
    
    steps:
      - name: Update deployment status
        run: |
          echo "üéâ Deployment Summary:"
          echo "üì¶ Version: ${{ needs.validate.outputs.build_version }}"
          echo "üè™ Registry: ${{ needs.validate.outputs.registry_url }}"
          echo "üöÄ Environment: ${{ env.BUILD_ENVIRONMENT }}"
          echo "üì± App ID: ${{ needs.deploy.outputs.app_id }}"
          
          if [[ "${{ needs.deploy.outputs.deployment_status }}" == "success" ]]; then
            echo "‚úÖ Deployment completed successfully!"
          else
            echo "‚ùå Deployment encountered issues"
          fi

      - name: Cleanup old images (optional)
        run: |
          echo "üßπ Consider implementing image cleanup for old versions"
          echo "This helps manage registry storage costs"

  # Rollback strategy in case of failure
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: ${{ failure() && needs.deploy.result == 'failure' }}
    
    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Trigger rollback
        run: |
          APP_ID="${{ secrets.DIGITALOCEAN_APP_ID }}"
          
          if [[ -n "$APP_ID" ]]; then
            echo "üîÑ Initiating rollback for App ID: $APP_ID"
            
            # Get previous deployment
            PREV_DEPLOYMENT=$(doctl apps list-deployments $APP_ID --format ID --no-header | sed -n '2p')
            
            if [[ -n "$PREV_DEPLOYMENT" ]]; then
              echo "‚è™ Rolling back to deployment: $PREV_DEPLOYMENT"
              # Note: DigitalOcean doesn't have direct rollback, so we would need to
              # redeploy with previous image tags or configuration
              echo "Manual rollback may be required via DigitalOcean dashboard"
            else
              echo "‚ùå No previous deployment found for rollback"
            fi
          else
            echo "‚ùå No app ID available for rollback"
          fi

      - name: Notify rollback
        run: |
          echo "üö® Deployment failed and rollback was attempted"
          echo "Please check the deployment logs and manually verify the application state"