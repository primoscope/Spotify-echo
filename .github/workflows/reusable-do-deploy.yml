# Reusable workflow for DigitalOcean App Platform deployment
# This template can be used by other services or projects that need DigitalOcean App Platform deployment
name: DigitalOcean App Deploy

on:
  workflow_call:
    inputs:
      app_name:
        description: 'DigitalOcean App Platform application name'
        required: true
        type: string
      environment:
        description: 'Deployment environment'
        required: false
        type: string
        default: 'production'
      app_spec_path:
        description: 'Path to app specification file'
        required: false
        type: string
        default: 'app.yaml'
      registry_namespace:
        description: 'Container registry namespace'
        required: false
        type: string
        default: 'echotune-registry'
      health_check_path:
        description: 'Health check endpoint path'
        required: false
        type: string
        default: '/health'
      deployment_timeout:
        description: 'Deployment timeout in seconds'
        required: false
        type: number
        default: 1800
      enable_rollback:
        description: 'Enable automatic rollback on failure'
        required: false
        type: boolean
        default: true
      wait_for_deployment:
        description: 'Wait for deployment to complete'
        required: false
        type: boolean
        default: true
    
    secrets:
      DIGITALOCEAN_ACCESS_TOKEN:
        description: 'DigitalOcean API access token'
        required: true
      DO_APP_ID:
        description: 'DigitalOcean App Platform application ID (optional for new apps)'
        required: false
      NOTIFICATION_WEBHOOK:
        description: 'Webhook URL for deployment notifications (optional)'
        required: false
    
    outputs:
      app_id:
        description: 'DigitalOcean App Platform application ID'
        value: ${{ jobs.deploy.outputs.app_id }}
      app_url:
        description: 'Application URL'
        value: ${{ jobs.deploy.outputs.app_url }}
      deployment_id:
        description: 'Deployment ID'
        value: ${{ jobs.deploy.outputs.deployment_id }}
      deployment_status:
        description: 'Final deployment status'
        value: ${{ jobs.deploy.outputs.status }}

env:
  DO_REGISTRY: registry.digitalocean.com

jobs:
  deploy:
    name: Deploy to DigitalOcean App Platform
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    outputs:
      app_id: ${{ steps.deploy.outputs.app_id }}
      app_url: ${{ steps.url.outputs.app_url }}
      deployment_id: ${{ steps.deployment.outputs.deployment_id }}
      status: ${{ steps.deployment-status.outputs.status }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Validate app specification
        id: validate
        run: |
          APP_SPEC="${{ inputs.app_spec_path }}"
          
          if [[ ! -f "$APP_SPEC" ]]; then
            echo "‚ùå App specification file not found: $APP_SPEC"
            exit 1
          fi
          
          # Validate YAML syntax
          if command -v yq &> /dev/null; then
            yq eval '.' "$APP_SPEC" > /dev/null || {
              echo "‚ùå Invalid YAML syntax in $APP_SPEC"
              exit 1
            }
          fi
          
          echo "‚úÖ App specification validated: $APP_SPEC"

      - name: Prepare deployment configuration
        id: prepare
        run: |
          APP_SPEC="${{ inputs.app_spec_path }}"
          DEPLOY_SPEC="app-deploy-${GITHUB_RUN_ID}.yaml"
          
          # Copy and update app specification
          cp "$APP_SPEC" "$DEPLOY_SPEC"
          
          # Update image references if using container deployment
          REGISTRY_URL="${{ env.DO_REGISTRY }}/${{ inputs.registry_namespace }}"
          BUILD_VERSION="${{ github.sha }}"
          
          # Replace image references with new tags
          if grep -q "image:" "$DEPLOY_SPEC"; then
            sed -i "s|image: .*${{ inputs.app_name }}.*|image: ${REGISTRY_URL}/${{ inputs.app_name }}:${BUILD_VERSION}|g" "$DEPLOY_SPEC"
            echo "üîÑ Updated image references in deployment spec"
          fi
          
          echo "deployment_spec=${DEPLOY_SPEC}" >> $GITHUB_OUTPUT
          echo "üìã Prepared deployment spec: $DEPLOY_SPEC"

      - name: Create or update DigitalOcean App
        id: deploy
        run: |
          APP_ID="${{ secrets.DO_APP_ID }}"
          DEPLOY_SPEC="${{ steps.prepare.outputs.deployment_spec }}"
          
          if [[ -z "$APP_ID" ]]; then
            echo "üöÄ Creating new DigitalOcean App: ${{ inputs.app_name }}"
            
            APP_RESPONSE=$(doctl apps create "$DEPLOY_SPEC" --format ID --no-header)
            APP_ID="$APP_RESPONSE"
            
            if [[ -z "$APP_ID" ]]; then
              echo "‚ùå Failed to create app"
              exit 1
            fi
            
            echo "‚úÖ Created new app with ID: $APP_ID"
            echo "app_id=$APP_ID" >> $GITHUB_OUTPUT
            echo "action=created" >> $GITHUB_OUTPUT
          else
            echo "üîÑ Updating existing DigitalOcean App (ID: $APP_ID)"
            
            doctl apps update "$APP_ID" --spec "$DEPLOY_SPEC"
            echo "‚úÖ Updated existing app: $APP_ID"
            echo "app_id=$APP_ID" >> $GITHUB_OUTPUT
            echo "action=updated" >> $GITHUB_OUTPUT
          fi

      - name: Create deployment
        id: deployment
        if: ${{ inputs.wait_for_deployment }}
        run: |
          APP_ID="${{ steps.deploy.outputs.app_id }}"
          
          echo "üöÄ Creating new deployment for App ID: $APP_ID"
          DEPLOYMENT_ID=$(doctl apps create-deployment "$APP_ID" --format ID --no-header)
          
          if [[ -z "$DEPLOYMENT_ID" ]]; then
            echo "‚ùå Failed to create deployment"
            exit 1
          fi
          
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Deployment created: $DEPLOYMENT_ID"

      - name: Wait for deployment completion
        id: deployment-status
        if: ${{ inputs.wait_for_deployment }}
        run: |
          APP_ID="${{ steps.deploy.outputs.app_id }}"
          DEPLOYMENT_ID="${{ steps.deployment.outputs.deployment_id }}"
          TIMEOUT="${{ inputs.deployment_timeout }}"
          
          echo "‚è≥ Waiting for deployment to complete (timeout: ${TIMEOUT}s)..."
          
          ELAPSED=0
          INTERVAL=30
          
          while [[ $ELAPSED -lt $TIMEOUT ]]; do
            STATUS=$(doctl apps get-deployment "$APP_ID" "$DEPLOYMENT_ID" --format Phase --no-header)
            echo "üîç Deployment status: $STATUS (elapsed: ${ELAPSED}s)"
            
            case "$STATUS" in
              "ACTIVE")
                echo "‚úÖ Deployment completed successfully!"
                echo "status=success" >> $GITHUB_OUTPUT
                exit 0
                ;;
              "ERROR"|"CANCELED")
                echo "‚ùå Deployment failed with status: $STATUS"
                
                # Get deployment logs for debugging
                echo "üìã Deployment logs:"
                doctl apps get-deployment "$APP_ID" "$DEPLOYMENT_ID" --format ID,Phase,Progress,CreatedAt,UpdatedAt
                
                echo "status=failed" >> $GITHUB_OUTPUT
                exit 1
                ;;
              "PENDING"|"DEPLOYING")
                echo "‚è≥ Deployment in progress..."
                sleep $INTERVAL
                ELAPSED=$((ELAPSED + INTERVAL))
                ;;
              *)
                echo "‚ùì Unknown deployment status: $STATUS"
                sleep $INTERVAL
                ELAPSED=$((ELAPSED + INTERVAL))
                ;;
            esac
          done
          
          echo "‚ùå Deployment timed out after ${TIMEOUT} seconds"
          echo "status=timeout" >> $GITHUB_OUTPUT
          exit 1

      - name: Get application URL
        id: url
        run: |
          APP_ID="${{ steps.deploy.outputs.app_id }}"
          APP_URL=$(doctl apps get "$APP_ID" --format DefaultIngress --no-header)
          
          if [[ -n "$APP_URL" ]]; then
            # Ensure URL has protocol
            if [[ ! "$APP_URL" =~ ^https?:// ]]; then
              APP_URL="https://$APP_URL"
            fi
            
            echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
            echo "üåê Application URL: $APP_URL"
          else
            echo "‚ö†Ô∏è No application URL available"
          fi

      - name: Health check
        id: health-check
        if: ${{ steps.url.outputs.app_url != '' }}
        run: |
          APP_URL="${{ steps.url.outputs.app_url }}"
          HEALTH_PATH="${{ inputs.health_check_path }}"
          HEALTH_URL="${APP_URL}${HEALTH_PATH}"
          
          echo "üîç Performing health check on: $HEALTH_URL"
          
          # Wait for application to be ready
          sleep 60
          
          # Health check with retries
          for i in {1..5}; do
            if curl -f -s --max-time 30 "$HEALTH_URL" > /dev/null; then
              echo "‚úÖ Health check passed!"
              echo "status=healthy" >> $GITHUB_OUTPUT
              break
            else
              echo "‚ö†Ô∏è Health check attempt $i failed, retrying in 30s..."
              sleep 30
            fi
            
            if [[ $i -eq 5 ]]; then
              echo "‚ùå Health check failed after 5 attempts"
              echo "status=unhealthy" >> $GITHUB_OUTPUT
            fi
          done

      - name: Send notification
        if: ${{ always() && secrets.NOTIFICATION_WEBHOOK != '' }}
        run: |
          STATUS="${{ steps.deployment-status.outputs.status }}"
          APP_URL="${{ steps.url.outputs.app_url }}"
          
          if [[ "$STATUS" == "success" ]]; then
            MESSAGE="‚úÖ Deployment successful for ${{ inputs.app_name }}"
            COLOR="good"
          else
            MESSAGE="‚ùå Deployment failed for ${{ inputs.app_name }}"
            COLOR="danger"
          fi
          
          if [[ -n "$APP_URL" ]]; then
            MESSAGE="$MESSAGE\nüåê URL: $APP_URL"
          fi
          
          # Send webhook notification (example for Slack format)
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"$MESSAGE\",\"color\":\"$COLOR\"}" \
            "${{ secrets.NOTIFICATION_WEBHOOK }}" || echo "Failed to send notification"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: ${{ failure() && inputs.enable_rollback && needs.deploy.outputs.app_id != '' }}
    
    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Attempt rollback
        run: |
          APP_ID="${{ needs.deploy.outputs.app_id }}"
          
          echo "üîÑ Attempting rollback for App ID: $APP_ID"
          
          # Get list of deployments
          DEPLOYMENTS=$(doctl apps list-deployments "$APP_ID" --format ID,Phase --no-header)
          
          # Find the last successful deployment
          PREV_DEPLOYMENT=$(echo "$DEPLOYMENTS" | grep "ACTIVE" | head -1 | awk '{print $1}')
          
          if [[ -n "$PREV_DEPLOYMENT" ]]; then
            echo "‚è™ Found previous active deployment: $PREV_DEPLOYMENT"
            echo "Manual rollback may be required via DigitalOcean dashboard"
            echo "Previous deployment ID: $PREV_DEPLOYMENT"
          else
            echo "‚ùå No previous active deployment found for rollback"
          fi
          
          # Log deployment history for manual intervention
          echo "üìã Recent deployments:"
          echo "$DEPLOYMENTS"

      - name: Rollback notification
        if: ${{ secrets.NOTIFICATION_WEBHOOK != '' }}
        run: |
          MESSAGE="üö® Deployment failed for ${{ inputs.app_name }} - rollback attempted"
          
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"$MESSAGE\",\"color\":\"warning\"}" \
            "${{ secrets.NOTIFICATION_WEBHOOK }}" || echo "Failed to send rollback notification"